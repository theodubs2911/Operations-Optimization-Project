"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2010-2025 Google LLC
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class CapacityConstraintProto(google.protobuf.message.Message):
    """Represents a capacity constraint to be used in conjunction with a
    SetCoverProto. This constraint only considers one dimension.

    Such a capacity constraint mathematically looks like:
        min_capacity <= \\sum_{e in elements} weight_e * x_e <= max_capacity
    where either `min_capacity` or `max_capacity` can be omitted. `x_e` indicates
    for a given solution `x` whether the element `e` is selected and counts for
    this capacity constraint (`x_e == 1`) or not (`x_e == 0`). The weights are
    given in `capacity_term`, each of them being a reference to an element being
    present in a subset (in set-covering parlance) and its weight.

    For instance, this constraint can be used together with a set-covering
    problem where parcels (element) must be covered by trucks (subsets) while
    respecting truck capacities (this object). Each element can be covered by a
    given set of trucks (set-covering problem); if an element is taken within a
    truck, it uses some capacity for this truck (such as weight).

    In particular, this representation does not imply that a given element must
    have the same weight in all the capacity constraints of a set-covering
    problem (e.g., the same parcel might have different weights depending on
    which truck is being considered).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class CapacityTerm(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class ElementWeightPair(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            ELEMENT_FIELD_NUMBER: builtins.int
            WEIGHT_FIELD_NUMBER: builtins.int
            element: builtins.int
            """The element this weight corresponds to (value of `element` in
            `SetCoverProto.Subset`).
            """
            weight: builtins.int
            """The weight of the element."""
            def __init__(
                self,
                *,
                element: builtins.int = ...,
                weight: builtins.int = ...,
            ) -> None: ...
            def ClearField(self, field_name: typing.Literal["element", b"element", "weight", b"weight"]) -> None: ...

        SUBSET_FIELD_NUMBER: builtins.int
        ELEMENT_WEIGHTS_FIELD_NUMBER: builtins.int
        subset: builtins.int
        """The subset this weight corresponds to (index of the subset in the
        `subset` repeated field in `SetCoverProto`).
        """
        @property
        def element_weights(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CapacityConstraintProto.CapacityTerm.ElementWeightPair]: ...
        def __init__(
            self,
            *,
            subset: builtins.int = ...,
            element_weights: collections.abc.Iterable[global___CapacityConstraintProto.CapacityTerm.ElementWeightPair] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["element_weights", b"element_weights", "subset", b"subset"]) -> None: ...

    CAPACITY_TERM_FIELD_NUMBER: builtins.int
    MIN_CAPACITY_FIELD_NUMBER: builtins.int
    MAX_CAPACITY_FIELD_NUMBER: builtins.int
    min_capacity: builtins.int
    """The minimum amount of resource that must be consumed. At least one of
    `min_capacity` and `max_capacity` must be present.
    """
    max_capacity: builtins.int
    """The maximum amount of resource that can be consumed. At least one of
    `min_capacity` and `max_capacity` must be present.
    """
    @property
    def capacity_term(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CapacityConstraintProto.CapacityTerm]:
        """The list of terms in the constraint.

        The list is supposed to be in canonical form, which means it is sorted
        first by increasing subset index then increasing element index.
        No duplicate term is allowed (two terms for the same element in the same
        subset).
        """

    def __init__(
        self,
        *,
        capacity_term: collections.abc.Iterable[global___CapacityConstraintProto.CapacityTerm] | None = ...,
        min_capacity: builtins.int = ...,
        max_capacity: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["capacity_term", b"capacity_term", "max_capacity", b"max_capacity", "min_capacity", b"min_capacity"]) -> None: ...

global___CapacityConstraintProto = CapacityConstraintProto
